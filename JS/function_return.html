<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fuction-return</title>
    <script>
        //return: 함수의 수행을 종료하고 호출한 곳으로 돌아가는 역할
        function f1(){
            for(var i=1;i<10;i++){
                
                if(i%3==0){
                    //수행을 종료하고 호출한 곳으로 돌아가기 때문에
                    //break와 유사한 효과를 만들 수 있다.
                    //break;
                    return;
                }
                console.log(i);
            }
        }
        f1();
        //return의 또 다른 역할은 하나의 데이터를 호출한 곳으로 가지고 갈 수 있당.
        function f2(first, second){
            return first+second;
        }
        //함수를 호출하고 리턴한 결과를 저장, 메모리를 더 사용
        console.log(f2(1,2));
        var result=f2(f2(100,200),300);
        console.log(result);

        var imsi=f2(100,200);
        result=f2(imsi,300);
        console.log(result);
        //라인을 줄인다고 좋은건 아닝이ㅣㅇ이야아아아아

        //1부터 n까지의 합계
        const sum=(n)=>{
            //중단점
            if(n==1){
                return 1;
            }
            //자기 자신을 리턴 - 재귀
            return n+sum(n-1);
        }

        console.log(sum(10));

        //피보나치 수열
        //첫번째와 두번째는 무조건 1
        // 세번째부터는 앞의 두개의 합
        //1, 1, 2, 3, 5, 8, 13, 21
        const fibo_recursion=(n)=>{
            if(n==1 || n==2){
                return 1;
            }else{
                return fibo_recursion(n-2)+fibo_recursion(n-1);
            }
        }

        console.log(fibo_recursion(10));

        //재귀 이용하지 않기
        const fibo_norecursion=(n)=>{
            let n1=1;
            let n2=1;
            let fibo=1;
            for(var i=3;i<=n;i++){
                fibo=n1+n2;
                n2=n1;
                n1=fibo;
            }
            return fibo;
        }

        console.log(fibo_norecursion(10));  
        
        //setInterval(함수, 주기): 주기마다 함수를 호출해서 실행하는 함수
        // 함수를 대입받아서 상태변화가 생길 때 호출되도록 하는 것이 callback
        //주기는 ms단위
        setInterval(()=>{
            console.log("콜백을 이용한 타이머 실행");
        },5000)

        //Nested Function
        function outer(){
            function inner(){

            }
            //High Order Function
            return inner;
        }

        function out(){
            let x=0;
        }

        //console.log(x);//에러

        function out2(){
            let x=0;
            return x;
        }
        var result=out2();
        console.log(result); // 안에 변수를 조작할 수는 없어

        function out3(){
            let x=0;
            //함수를 만들어서 리턴하는데 이 함수는 함수 내에 있는 함수이므로
            //외부에 있는 데이터를 조작하는 것이 가능
            return ()=>{
                x++;
                console.log("x: "+x);
            }
        }
        //함수를 호출해서 함수를 리턴받아서 저장
        result=out3();
        //리턴받은 함수를 호출하면 outer안에 있는 x값이 수정
        //작업한 내역을 함수 안에 저장하면서 작업을 계속하는 것이 가능- 클로저
        result();
        result(); 
        
        //ECMA 2015에서 매개변수에 기본값을 설정하는 문법이 추가
        const f3=function(n=1){
            //예전에는 or를 이용해서 기본값 설정
            
           // const radius=n || 1;
            return Math.PI*n*n;
        }

        console.log("값 줌:"+f3(10));
        console.log("값 엑스:"+f3());

        var r=confirm("식사는 하셨슈?");
        console.log(r);

        var input=prompt("이름을 입력하세요: ","noname");
        console.log(input);

    </script>
</head>
<body>
    
</body>
</html>